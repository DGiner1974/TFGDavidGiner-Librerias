/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package es.uned.TFGDavidGiner.core;

import es.uned.TFGDavidGiner.core.interfaces.IShareableProperties;
import java.awt.Component;
import java.awt.Container;
import java.awt.LayoutManager;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.SwingUtilities;
import es.uned.TFGDavidGiner.core.interfaces.IValidation;

/**
 * Clase abstracta que representa un contenedor base para componentes de la interfaz gráfica.
 * Es el contenedor base del que heredan los contenedores de los LeakComponent. 
 * Extiende {@link BaseComponent} y gestiona un conjunto de componentes hijos.
 * Su principal funcionalidad es establecer automáticamente la sincronización de datos
 * entre los componentes {@link LeafComponent} que contiene, basándose en propiedades compartidas.
 * También propaga las llamadas de validación y configuración a sus componentes descendientes.
 *
 * @author david
 * @version 1.0
 */
public abstract class BaseContainer extends BaseComponent {

    /**
     * Constructor por defecto. Inicializa el contenedor y sus componentes.
     */
    public BaseContainer() {
        initComponents();
    }

    /**
     * Constructor que permite especificar un gestor de layout.
     *
     * @param layout El {@link LayoutManager} a utilizar para organizar los componentes.
     */
    public BaseContainer(LayoutManager layout) {
        super(layout);
        initComponents();
    }

    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Añade un {@link PropertyChangeListener} para sincronizar una propiedad entre dos componentes.
     * Cuando una propiedad compartida cambia en el componente de origen, el cambio se propaga
     * al componente de destino. La sincronización es unidireccional (origen -> destino).
     *
     * @param origin El componente que implementa la interface {@link IShareableProperties} de origen que emite el evento de cambio.
     * @param destiny El componente que implementa la interface {@link IShareableProperties} de destino que recibirá la actualización.
     */
    private void AddListener(Component originComp, Component destinyComp) {
        IShareableProperties origin = (IShareableProperties) originComp;
        IShareableProperties destiny = (IShareableProperties) destinyComp;
        PropertyChangeListener synchronizer = new PropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                // Obtener el nombre de la propiedad que ha cambiado.
                String propertyName = evt.getPropertyName();

                // Identificar las propiedades comunes y compartidas entre los dos componentes.
                Set<String> setpropcomunes = origin.propertiesInCommon(destiny.getSharedProperies());

                // Si la propiedad que cambió está en el conjunto de propiedades comunes...
                if (setpropcomunes.contains(propertyName)) {
                    Map<String, Class<?>> map1 = (origin).getPropertiesType(setpropcomunes);
                    Map<String, Class<?>> map2 = (destiny).getPropertiesType(setpropcomunes);
                    Class<?> originprop = map1.get(propertyName);
                    Class<?> destinyprop = map2.get(propertyName);
                    // ...y si los tipos de la propiedad en ambos componentes son compatibles...
                    if (destinyprop.getName().equals(originprop.getName())) {
                        try {
                            // Usar reflexión para obtener el valor actualizado del componente de origen.
                            String nombreGetter = "get" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                            Method getter = origin.getClass().getMethod(nombreGetter);
                            Object getterSource = getter.invoke(origin);

                            // Usar reflexión para obtener el valor actual del componente de destino.
                            Method getterT = destiny.getClass().getMethod(nombreGetter);
                            Object getterTarget = getterT.invoke(destiny);

                            // Actualizar el destino solo si el valor es diferente, para evitar ciclos infinitos.
                            if (getterTarget != getterSource) {
                                // Construir y invocar el método setter en el componente de destino.
                                String setterName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);
                                Method setter = destiny.getClass().getMethod(setterName, destinyprop);
                                setter.invoke(destiny, getterSource);
                            }
                        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | IllegalArgumentException ex) {
                            // Registrar cualquier excepción ocurrida durante el proceso de reflexión.
                            Logger.getLogger(BaseContainer.class.getName()).log(Level.SEVERE, "Error al sincronizar propiedad '" + propertyName + "'", ex);
                        }
                    }
                }
            }
        };
        // Añadir el listener al componente de origen para que escuche los cambios.
        ((BaseComponent)origin).addPropertyChangeListener(synchronizer);
    }

    /**
     * Se invoca cuando el componente se añade a un contenedor.
     * Sobrescribe el método para configurar la sincronización de propiedades entre
     * todos los componentes hoja {@link LeafComponent} que contiene.
     */
    @Override
    public void addNotify() {
        super.addNotify();
        // Asegura que el código se ejecute en el Event Dispatch Thread (EDT) de Swing.
        SwingUtilities.invokeLater(() -> {
            revalidate();
            repaint();
            
            // Obtener todos los componentes hoja (descendientes) de este contenedor.
            Component[] componentList = this.getComponentsHoja();
            for (Component c : componentList) {
                if (c instanceof IShareableProperties ) {
                    for (Component c2 : componentList) {
                        // Para cada par de componentes hoja distintos, establecer un listener.
                        // Esto crea una sincronización en ambas direcciones.
                        if (c2 instanceof IShareableProperties  && c != c2) {
                            AddListener(c2, c);
                        }
                    }
                }
            }
        });
    }

    /**
     * Obtiene de forma recursiva todos los componentes de tipo {@link LeafComponent}
     * que descienden de este contenedor.
     *
     * @return Un array de {@link Component} con todos los componentes hoja encontrados.
     */
    public Component[] getComponentsHoja() {
        List<Component> listaComponentes = new ArrayList<>();
        Component[] lc = this.getComponents();
        for (Component c : lc) {
            if (c instanceof BaseComponent) {
                BaseComponent baseComp = (BaseComponent) c;
                if (baseComp.isLeaf()) {
                    // Si es un componente hoja, se añade a la lista.
                    listaComponentes.add(baseComp);
                } else {
                    // Si es otro BaseContainer, se llama recursivamente para obtener sus hojas.
                    listaComponentes.addAll(Arrays.asList(((BaseContainer) baseComp).getComponentsHoja()));
                }
            } else if (c instanceof Container) {
                // Si es un contenedor estándar de Swing, se busca recursivamente en él.
                listaComponentes.addAll(Arrays.asList(this.getComponentsHoja((Container) c)));
            }
        }
        return listaComponentes.toArray(new Component[0]);
    }

    /**
     * Obtiene de forma recursiva todos los componentes de tipo {@link LeafComponent}
     * que descienden de un contenedor específico.
     *
     * @param cp El {@link Container} desde el que empezar la búsqueda.
     * @return Un array de {@link Component} con todos los componentes hoja encontrados.
     */
    public Component[] getComponentsHoja(Container cp) {
        List<Component> listaComponentes = new ArrayList<>();
        Component[] lc = cp.getComponents();
        for (Component c : lc) {
            if (c instanceof BaseComponent) {
                BaseComponent baseComp = (BaseComponent) c;
                if (baseComp.isLeaf()) {
                    // Si es un componente hoja, se añade a la lista.
                    listaComponentes.add(baseComp);
                } else {
                    // Si es un BaseContainer, se llama a su propio método para obtener las hojas.
                    listaComponentes.addAll(Arrays.asList(((BaseContainer) baseComp).getComponentsHoja()));
                }
            } else if (c instanceof Container) {
                // Si es otro tipo de contenedor, se sigue la recursión.
                listaComponentes.addAll(Arrays.asList(this.getComponentsHoja((Container) c)));
            }
        }
        return listaComponentes.toArray(new Component[0]);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
     /**
     * Ejecuta el método {@code configurar()} en cada componente descendiente que implemente
     * la interfaz {@link IValidation}.
     * El método devuelve {@code false} si la configuración falla en cualquiera de los componentes.
     *
     * @return {@code true} si todos los componentes se configuraron correctamente, {@code false} en caso contrario.
     */
    @Override
    public boolean configurar() {
        boolean resultado = true;
        Component[] lc = getComponentsHoja();
        for (Component c : lc) {
            if (c instanceof IValidation) {
                if (!((IValidation) c).configurar()) {
                    resultado = false;
                }
            }
        }
        return resultado;
    }

    /**
     * Ejecuta el método {@code validar()} en cada componente descendiente que implemente
     * la interfaz {@link IValidation}.
     * El método devuelve {@code false} si la validación falla en cualquiera de los componentes.
     *
     * @return {@code true} si todos los componentes son válidos, {@code false} en caso contrario.
     */
    @Override
    public boolean validar() {
        boolean resultado = true;
        Component[] lc = getComponentsHoja();
        for (Component c : lc) {
            if (c instanceof IValidation) {
                if (!((IValidation) c).validar()) {
                    resultado = false;
                }
            }
        }
        return resultado;
    }

    /**
     * Ejecuta el método {@code getError()} en cada componente descendiente que implemente
     * la interfaz {@link IValidation} y concatena todos los mensajes de error.
     *
     * @return Una cadena con todos los mensajes de error, separados por saltos de línea.
     * Devuelve una cadena vacía si no hay errores.
     */
    @Override
    public String getError() {
        String error = "";
        String errorAux;
        Component[] lc = getComponentsHoja();
        for (Component c : lc) {
            if (c instanceof IValidation) {
                errorAux = ((IValidation) c).getError();
                if (errorAux != null && !errorAux.trim().isEmpty()) {
                    if (!error.isEmpty()) {
                        error += "\n";
                    }
                    error += errorAux;
                }
            }
        }
        return error;
    }
    
    @Override
    public boolean isLeaf() {
        return false;
    }
}